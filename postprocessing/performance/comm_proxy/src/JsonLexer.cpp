/* Generated by re2c 2.2 on Thu Oct 19 07:04:58 2023 */
#line 1 "src/JsonLexer.re"
// Copyright (C) 2023 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause

// re2c -o src/JsonLexer.cpp src/JsonLexer.re --case-ranges

#include "JsonLexer.hpp"

#include <cerrno>
#include <cstdlib>

namespace seissol {

JsonLexer::JsonLexer(char const* input) : YYCURSOR{input} {}

JsonTokenKind JsonLexer::operator()(JsonToken& tok) {
  char const* YYMARKER;
  JsonLexerError errc = JsonLexerError::None;
lex:
  char const* b = YYCURSOR;
  
#line 24 "src/JsonLexer.cpp"
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00: goto yy2;
	case '\t' ... '\v':
	case '\r':
	case ' ': goto yy6;
	case '"': goto yy9;
	case ',': goto yy11;
	case '-': goto yy13;
	case '0': goto yy14;
	case '1' ... '9': goto yy16;
	case ':': goto yy18;
	case '[': goto yy20;
	case ']': goto yy22;
	case 'f': goto yy24;
	case 'n': goto yy25;
	case 't': goto yy26;
	case '{': goto yy27;
	case '}': goto yy29;
	default: goto yy4;
	}
yy2:
	++YYCURSOR;
#line 74 "src/JsonLexer.re"
	{ return JsonTokenKind::EOI; }
#line 53 "src/JsonLexer.cpp"
yy4:
	++YYCURSOR;
yy5:
#line 75 "src/JsonLexer.re"
	{ tok.val = JsonLexerError::None; return JsonTokenKind::Unknown; }
#line 59 "src/JsonLexer.cpp"
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t' ... '\v':
	case '\r':
	case ' ': goto yy6;
	default: goto yy8;
	}
yy8:
#line 73 "src/JsonLexer.re"
	{ goto lex; }
#line 71 "src/JsonLexer.cpp"
yy9:
	yych = *++YYCURSOR;
	switch (yych) {
	case '"': goto yy31;
	case '\\': goto yy33;
	default: goto yy9;
	}
yy11:
	++YYCURSOR;
#line 42 "src/JsonLexer.re"
	{ return JsonTokenKind::ValueSeparator; }
#line 83 "src/JsonLexer.cpp"
yy13:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0': goto yy14;
	case '1' ... '9': goto yy16;
	default: goto yy5;
	}
yy14:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '.': goto yy35;
	case 'E':
	case 'e': goto yy37;
	default: goto yy15;
	}
yy15:
#line 48 "src/JsonLexer.re"
	{
          tok.val = lexIntegerNumber(b, YYCURSOR, errc);
          if (errc != JsonLexerError::None) {
              tok.val = errc;
              return JsonTokenKind::Unknown;
          }
          return JsonTokenKind::IntegerNumber;
      }
#line 110 "src/JsonLexer.cpp"
yy16:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '.': goto yy35;
	case '0' ... '9': goto yy16;
	case 'E':
	case 'e': goto yy37;
	default: goto yy15;
	}
yy18:
	++YYCURSOR;
#line 41 "src/JsonLexer.re"
	{ return JsonTokenKind::NameSeparator; }
#line 125 "src/JsonLexer.cpp"
yy20:
	++YYCURSOR;
#line 37 "src/JsonLexer.re"
	{ return JsonTokenKind::BeginArray; }
#line 130 "src/JsonLexer.cpp"
yy22:
	++YYCURSOR;
#line 38 "src/JsonLexer.re"
	{ return JsonTokenKind::EndArray; }
#line 135 "src/JsonLexer.cpp"
yy24:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'a': goto yy38;
	default: goto yy5;
	}
yy25:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'u': goto yy39;
	default: goto yy5;
	}
yy26:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'r': goto yy40;
	default: goto yy5;
	}
yy27:
	++YYCURSOR;
#line 39 "src/JsonLexer.re"
	{ return JsonTokenKind::BeginObject; }
#line 161 "src/JsonLexer.cpp"
yy29:
	++YYCURSOR;
#line 40 "src/JsonLexer.re"
	{ return JsonTokenKind::EndObject; }
#line 166 "src/JsonLexer.cpp"
yy31:
	++YYCURSOR;
#line 64 "src/JsonLexer.re"
	{
          tok.val = lexString(b + 1, YYCURSOR, errc);
          if (errc != JsonLexerError::None) {
              tok.val = errc;
              return JsonTokenKind::Unknown;
          }
          return JsonTokenKind::String;
      }
#line 178 "src/JsonLexer.cpp"
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\\': goto yy33;
	default: goto yy9;
	}
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0' ... '9': goto yy41;
	default: goto yy36;
	}
yy36:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
	case 0:
		goto yy15;
	case 1:
		goto yy5;
	default:
		goto yy43;
	}
yy37:
	yych = *++YYCURSOR;
	switch (yych) {
	case '+':
	case '-': goto yy44;
	case '0' ... '9': goto yy45;
	default: goto yy36;
	}
yy38:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l': goto yy47;
	default: goto yy36;
	}
yy39:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l': goto yy48;
	default: goto yy36;
	}
yy40:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'u': goto yy49;
	default: goto yy36;
	}
yy41:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '0' ... '9': goto yy41;
	case 'E':
	case 'e': goto yy37;
	default: goto yy43;
	}
yy43:
#line 56 "src/JsonLexer.re"
	{
          tok.val = lexFloatingNumber(b, YYCURSOR, errc);
          if (errc != JsonLexerError::None) {
              tok.val = errc;
              return JsonTokenKind::Unknown;
          }
          return JsonTokenKind::FloatingNumber;
      }
#line 246 "src/JsonLexer.cpp"
yy44:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0' ... '9': goto yy45;
	default: goto yy36;
	}
yy45:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0' ... '9': goto yy45;
	default: goto yy43;
	}
yy47:
	yych = *++YYCURSOR;
	switch (yych) {
	case 's': goto yy50;
	default: goto yy36;
	}
yy48:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'l': goto yy51;
	default: goto yy36;
	}
yy49:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e': goto yy53;
	default: goto yy36;
	}
yy50:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'e': goto yy55;
	default: goto yy36;
	}
yy51:
	++YYCURSOR;
#line 47 "src/JsonLexer.re"
	{ return JsonTokenKind::Null; }
#line 287 "src/JsonLexer.cpp"
yy53:
	++YYCURSOR;
#line 46 "src/JsonLexer.re"
	{ return JsonTokenKind::True; }
#line 292 "src/JsonLexer.cpp"
yy55:
	++YYCURSOR;
#line 45 "src/JsonLexer.re"
	{ return JsonTokenKind::False; }
#line 297 "src/JsonLexer.cpp"
}
#line 76 "src/JsonLexer.re"

}

long JsonLexer::lexIntegerNumber(char const* s, char const* e, JsonLexerError& errc) {
  auto number = std::string(s, e);
  double d = strtol(number.c_str(), nullptr, 10);
  errc = errno == ERANGE ? JsonLexerError::IntegerOverflow : JsonLexerError::None;
  return d;
}

double JsonLexer::lexFloatingNumber(char const* s, char const* e, JsonLexerError& errc) {
  auto number = std::string(s, e);
  double d = strtod(number.c_str(), nullptr);
  errc = errno == ERANGE ? JsonLexerError::FloatingOutOfRange : JsonLexerError::None;
  return d;
}

std::string JsonLexer::lexString(char const* s, char const* e, JsonLexerError& errc) {
  char const* YYMARKER;
  auto str = std::string{};
  str.reserve(e - s);
  errc = JsonLexerError::None;
lex:
  char const* b = s;
  
#line 325 "src/JsonLexer.cpp"
{
	char yych;
	yych = *s;
	switch (yych) {
	case ' ' ... '!':
	case '#' ... '[':
	case ']' ... 0x7F: goto yy61;
	case '"': goto yy63;
	case '\\': goto yy65;
	default: goto yy59;
	}
yy59:
	++s;
yy60:
#line 128 "src/JsonLexer.re"
	{ errc = JsonLexerError::InvalidString; return {}; }
#line 342 "src/JsonLexer.cpp"
yy61:
	++s;
#line 107 "src/JsonLexer.re"
	{ str.push_back(*b); goto lex; }
#line 347 "src/JsonLexer.cpp"
yy63:
	++s;
#line 127 "src/JsonLexer.re"
	{ return str; }
#line 352 "src/JsonLexer.cpp"
yy65:
	yych = *++s;
	switch (yych) {
	case '"':
	case '/':
	case '\\':
	case 'b':
	case 'f':
	case 'n':
	case 'r':
	case 't': goto yy66;
	default: goto yy60;
	}
yy66:
	++s;
#line 108 "src/JsonLexer.re"
	{
          ++b; // skip escape char
          char c;
          switch(*b) {
          case 0x22:
          case 0x5C:
          case 0x2F:
              c = *b;
              break;
          case 0x62: c = 0x08; break;
          case 0x66: c = 0x0C; break;
          case 0x6E: c = 0x0A; break;
          case 0x72: c = 0x0D; break;
          case 0x74: c = 0x09; break;
          case 0x64: c = 0x22; break;
          };
          str.push_back(c);
          goto lex;
      }
#line 388 "src/JsonLexer.cpp"
}
#line 129 "src/JsonLexer.re"

  return str;
}

} // namespace seissol
