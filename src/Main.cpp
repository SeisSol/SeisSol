// SPDX-FileCopyrightText: 2014-2024 SeisSol Group
//
// SPDX-License-Identifier: BSD-3-Clause
// SPDX-LicenseComments: Full text under /LICENSE and /LICENSES/
//
// SPDX-FileContributor: Author lists in /AUTHORS and /CITATION.cff
// SPDX-FileContributor: Sebastian Rettenberger

#include "Initializer/Parameters/ParameterReader.h"
#include "Modules/Modules.h"
#include "Monitoring/Instrumentation.h"
#include <cstdlib>
#include <ctime>
#include <exception>
#include <fty/fty.hpp>
#include <memory>
#include <string>
#include <utils/args.h>
#include <utils/env.h>
#include <utils/logger.h>
#include <utils/timeutils.h>
#include <xdmfwriter/scorep_wrapper.h>
#include <yaml-cpp/yaml.h>

#include "Initializer/InitProcedure/Init.h"
#include "Initializer/Parameters/SeisSolParameters.h"
#include "SeisSol.h"

#include "Parallel/MPI.h"

#ifdef USE_ASAGI
#include "Reader/AsagiModule.h"
#endif

#ifdef ACL_DEVICE
#include "device.h"
#endif

#if defined(__GNUC__) || defined(__linux__)
#include <cfenv>
#include <fenv.h>
#endif

// Autogenerated file
#include "Version.h"

namespace {
std::shared_ptr<YAML::Node> readYamlParams(const std::string& parameterFile) {
  // Read parameter file input from file
  fty::Loader<fty::AsLowercase> loader{};
  std::shared_ptr<YAML::Node> inputParams = nullptr;
  try {
    inputParams = std::make_shared<YAML::Node>(loader.load(parameterFile));
  } catch (const std::exception& error) {
    logError() << "Error while reading the parameter file:" << std::string(error.what());
  }
  return inputParams;
}
} // namespace

int main(int argc, char* argv[]) {
#ifdef ACL_DEVICE
#ifdef USE_MPI
  seissol::MPI::mpi.bindAcceleratorDevice();
#endif // USE_MPI
  device::DeviceInstance& device = device::DeviceInstance::getInstance();
  device.api->initialize();
  device.api->allocateStackMem();
#endif // ACL_DEVICE

#ifdef USE_ASAGI
  // Construct an instance of AsagiModule, to initialize it.
  // It needs to be done here, as it registers PRE_MPI hooks
  seissol::asagi::AsagiModule::getInstance();
#endif
  // Call pre MPI hooks
  seissol::Modules::callHook<ModuleHook::PreMPI>();

  seissol::MPI::mpi.init(argc, argv);
  const int rank = seissol::MPI::mpi.rank();

  utils::Logger::setRank(rank);

  LIKWID_MARKER_INIT;
#pragma omp parallel
  {
    LIKWID_MARKER_THREADINIT;
    LIKWID_MARKER_REGISTER("SeisSol");
    LIKWID_MARKER_REGISTER("computeDynamicRuptureFrictionLaw");
    LIKWID_MARKER_REGISTER("computeDynamicRupturePostHook");
    LIKWID_MARKER_REGISTER("computeDynamicRupturePostcomputeImposedState");
    LIKWID_MARKER_REGISTER("computeDynamicRupturePreHook");
    LIKWID_MARKER_REGISTER("computeDynamicRupturePrecomputeStress");
    LIKWID_MARKER_REGISTER("computeDynamicRuptureSpaceTimeInterpolation");
    LIKWID_MARKER_REGISTER("computeDynamicRuptureUpdateFrictionAndSlip");
  }

#pragma omp parallel
  {
    LIKWID_MARKER_START("SeisSol");
  }

  EPIK_TRACER("SeisSol");
  SCOREP_USER_REGION("SeisSol", SCOREP_USER_REGION_TYPE_FUNCTION);

  // Print welcome message
  logInfo() << "Welcome to SeisSol";
  logInfo() << "Copyright (c) 2012 -" << COMMIT_YEAR << " SeisSol Group";
  logInfo() << "Version:" << VERSION_STRING;
  logInfo() << "Built on:" << __DATE__ << __TIME__;
#ifdef COMMIT_HASH
  logInfo() << "Last commit:" << COMMIT_HASH << "at" << COMMIT_TIMESTAMP;
#endif
  logInfo() << "Compiled with HOST_ARCH =" << SEISSOL_HOST_ARCH;
#ifdef ACL_DEVICE
  logInfo() << "Compiled with DEVICE_BACKEND =" << SEISSOL_DEVICE_BACKEND;
  logInfo() << "Compiled with DEVICE_ARCH =" << SEISSOL_DEVICE_ARCH;
#endif

  if (utils::Env::get<bool>("FLOATING_POINT_EXCEPTION", false)) {
    // Check if on a GNU system (Linux) or other platform
#if defined(__GNUC__) || defined(__linux__)
    feenableexcept(FE_ALL_EXCEPT & ~FE_INEXACT);
    logInfo() << "Enabling floating point exception handlers.";
#else
    logInfo() << "Floating-point exceptions not supported on this platform.";
#endif
  }

  // TODO Read parameters here
  // Parse command line arguments
  utils::Args args("SeisSol is a scientific software for the numerical simulation of seismic wave "
                   "phenomena and earthquake dynamics.");
  args.addAdditionalOption("file", "The parameter file", false);
  args.addOption(
      "checkpoint", 'c', "The checkpoint file to restart from", utils::Args::Optional, false);
  switch (args.parse(argc, argv)) {
  case utils::Args::Help: {
    [[fallthrough]];
  }
  case utils::Args::Error: {
    seissol::MPI::finalize();
    exit(1);
    break;
  }
  case utils::Args::Success: {
    break;
  }
  }
  const auto* parameterFile = args.getAdditionalArgument("file", "parameters.par");
  logInfo() << "Using the parameter file" << parameterFile;
  // read parameter file input
  const auto yamlParams = readYamlParams(parameterFile);
  seissol::initializer::parameters::ParameterReader parameterReader(
      *yamlParams, parameterFile, false);
  auto parameters = seissol::initializer::parameters::readSeisSolParameters(&parameterReader);
  parameterReader.warnUnknown();

  // Initialize SeisSol
  seissol::SeisSol seissolInstance(parameters);

  if (args.isSet("checkpoint")) {
    const auto* checkpointFile = args.getArgument<const char*>("checkpoint");
    seissolInstance.loadCheckpoint(checkpointFile);
  }

  // run SeisSol
  const bool runSeisSol = seissolInstance.init(argc, argv);

  const auto stamp = utils::TimeUtils::timeAsString("%Y-%m-%d_%H-%M-%S", time(nullptr));
  seissolInstance.setBackupTimeStamp(stamp);

  // Run SeisSol
  if (runSeisSol) {
    seissol::initializer::initprocedure::seissolMain(seissolInstance);
  }

#pragma omp parallel
  {
    LIKWID_MARKER_STOP("SeisSol");
  }

  LIKWID_MARKER_CLOSE;
  // Finalize SeisSol
  seissolInstance.finalize();

#ifdef ACL_DEVICE
  device.api->finalize();
#endif
  return 0;
}
